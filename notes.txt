chdir
close
closedir
dup
dup2
errno
execve
exit
fork
free
fstat
getcwd
kill
lstat
malloc
open
opendir
pipe
read
readdir
signal
stat
strerror
wait
wait3
wait4
waitpid
write


malloc
free
write
open
read
close
fork
wait
waitpid
wait3
wait4
signal
kill
exit
getcwd
chdir
stat
lstat
fstat
execve
dup
dup2
pipe
opendir
readdir
closedir
strerror
errno



words:
	-Reserved words		if while
	-Operators			| > 
	-Ordinary words		echo azerty


Your shell should:
• Search and launch the right executable (based on the PATH variable or by using
relative or absolute path) like in bash
• It must implement the builtins like in bash:
◦ echo with option ’-n’
◦ cd with only a relative or absolute path
◦ pwd without any options
◦ export without any options
◦ unset without any options
◦ env without any options and any arguments
◦ exit without any options
• ; in the command should separate commands like in bash
• ’ and " should work like in bash except for multiline commands
• Redirections < > “>>” should work like in bash except for file descriptor aggregation
4Minishell
As beautiful as a shell
• Pipes | should work like in bash
• Environment variables ($ followed by characters) should work like in bash
• $? should work like in bash
• ctrl-C, ctrl-D and ctrl-\ should have the same result as in bash


There are three types of quoting, each of which is slightly different and permits slightly different interpretations of the quoted text:
-the backslash, which escapes the next character.
-single quotes, which prevent interpretation of all enclosed characters.
-double quotes, which prevent some interpretation but allow certain word expansions as $VAR to be expanded (and treats backslashes differently).




good test:
	for for in for; do for=for; done; echo $for
	should echo "for"

	echo hugo "azerty       qsdfgh" $HOME "$HOME" '$HOME' \u \$HOME \"''h
	




$ echo $HOME
/home/hugothms

$ echo "$HOME"
/home/hugothms

$ echo "\$HOME"
$HOME

$ echo '$HOME'
$HOME

$ echo '\$HOME'
\$HOME
